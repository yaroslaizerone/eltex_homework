# HW10
# Задание 1
Реализуйте логику модулей keylist.erl и keylist_mgr.erl с помощью gen_server.
# Модуль keylist
```
-module(keylist).
-author("kolpa").

-behaviour(gen_server).

%% API
-export([start_link/1, add/4, is_member/2, take/2, find/2, delete/2, stop/1]).

%% Record definition
-record(key, {
  key :: any(),
  value :: any(),
  comment :: any()
}).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

%% API functions

%% @doc Start the keylist process
start_link(Name) ->
  gen_server:start_link({local, Name}, ?MODULE, [], []).

%% @doc Adds a record to the keylist with the specified key, value, and comment.
-spec add(atom(), any(), any(), any()) -> ok.
add(Name, Key, Value, Comment) ->
  gen_server:call(Name, {add, Key, Value, Comment}).

%% @doc Checks if the specified key is a member of the keylist.
-spec is_member(atom(), any()) -> boolean().
is_member(Name, Key) ->
  gen_server:call(Name, {is_member, Key}).

%% @doc Retrieves the record with the specified key from the keylist.
-spec take(atom(), any()) -> any().
take(Name, Key) ->
  gen_server:call(Name, {take, Key}).

%% @doc Finds the record with the specified key in the keylist.
-spec find(atom(), any()) -> any().
find(Name, Key) ->
  gen_server:call(Name, {find, Key}).

%% @doc Deletes the record with the specified key from the keylist.
-spec delete(atom(), any()) -> ok.
delete(Name, Key) ->
  gen_server:call(Name, {delete, Key}).

%% @doc Stops the keylist process.
-spec stop(atom()) -> ok.
stop(Name) ->
  gen_server:call(Name, stop).

%% gen_server callbacks

%% @doc Initializes the keylist process.
init([]) ->
  {ok, []}.

%% @doc Handles synchronous calls to the keylist process.
handle_call({add, Key, Value, Comment}, _From, List) ->
  NewList = [{Key, Value, Comment} | List],
  {reply, NewList, NewList};

handle_call({is_member, Key}, _From, List) ->
  Reply = lists:keymember(Key, 1, List),
  {reply, Reply, List};

handle_call({take, Key}, _From, List) ->
  case lists:keytake(Key, 1, List) of
    false ->
      {reply, not_found, List};

    {value, Record, NewList} ->
      {reply, Record, NewList}
  end;

handle_call({find, Key}, _From, List) ->
  Result = lists:keyfind(Key, 1, List),
  {reply, Result, List};

handle_call({delete, Key}, _From, List) ->
  NewList = lists:keydelete(Key, 1, List),
  {reply, ok, NewList};

handle_call(stop, _From, State) ->
  {stop, normal, ok, State};

handle_call(_Request, _From, State) ->
  {reply, unknown_request, State}.

%% @doc Handles asynchronous casts to the keylist process.
handle_cast(_Msg, State) ->
  {noreply, State}.

%% @doc Handles non-call, non-cast messages to the keylist process.
handle_info(_Info, State) ->
  {noreply, State}.

%% @doc Cleans up the keylist process.
terminate(_Reason, _State) ->
  ok.

%% @doc Handles code changes in the keylist process.
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.
```
# Модуль keylist_mgr
```
-module(keylist_mgr).
-author("kolpa").

-behaviour(gen_server).

%% API
-export([start/0, start_child/1, stop_child/1, stop/0, get_names/0]).

%% Record definition
-record(state, {children=[], permanent=[]}).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

%% API functions

%% @doc Start keylist_mgr
-spec start() -> {ok, Pid :: pid()} | {error, Reason :: term()}.
start() ->
  gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

%% @doc Start a child process
-spec start_child(Params :: #{name => atom(), restart => permanent | temporary}) -> ok.
start_child(Params) ->
  gen_server:cast(?MODULE, {start_child, Params}).

%% @doc Stop a child process
-spec stop_child(Name :: atom()) -> ok.
stop_child(Name) ->
  gen_server:cast(?MODULE, {stop_child, Name}).

%% @doc Stop keylist_mgr
-spec stop() -> ok.
stop() ->
  gen_server:cast(?MODULE, stop).

%% @doc Get the list of child process names
-spec get_names() -> ok.
get_names() ->
  gen_server:call(?MODULE, get_names).

%% gen_server callbacks

%% @doc Initializes the keylist_mgr process.
init([]) ->
  process_flag(trap_exit, true),
  {ok, #state{}}.

%% @doc Handles synchronous calls to the keylist_mgr process.
handle_call(get_names, _From, State) ->
  {reply, [Name || {Name, _} <- State#state.children], State};

handle_call(_Msg, _From, State) ->
  {reply, ok, State}.

%% @doc Handles asynchronous casts to the keylist_mgr process.
handle_cast({start_child, #{name := Name, restart := Restart}}, State) ->
  case Restart of
    temporary ->
      {noreply, State}; % Do nothing if restart is temporary
    _ ->
      case proplists:is_defined(Name, State#state.children) of
        false ->
          {ok, Pid} = keylist:start_link(Name),
          NewChildren =
            case Restart of
              permanent ->
                [{Name, Pid} | State#state.children];
              _ ->
                erlang:error(type_error)
            end,

          lists:foreach(fun({_, ChildPid}) -> ChildPid ! {added_new_child, Pid, Name} end, State#state.children),
          io:format("ChildList: ~p~n", [State#state.children]),
          {noreply, State#state{children = NewChildren}};
        true ->
          {reply, {error, already_started}, State}
      end
  end;

handle_cast({stop_child, Name}, State) ->
  case proplists:is_defined(Name, State#state.children) of
    true ->
      keylist:stop(Name),
      NewChildren = lists:keydelete(Name, 1, State#state.children),
      {noreply, State#state{children = NewChildren}};
    false ->
      {reply, {error, not_found}, State}
  end;

handle_cast(stop, State) ->
  lists:foreach(fun({_, Pid}) -> exit(Pid, kill) end, State#state.children),
  {stop, normal, ok}.

%% @doc Handles non-call, non-cast messages to the keylist_mgr process.
handle_info(_Info, State) ->
  {noreply, State}.

%% @doc Cleans up the keylist_mgr process.
terminate(_Reason, _State) ->
  ok.

%% @doc Handles code changes in the keylist_mgr process.
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.
```

# Задание 2 

```
lists:foreach(fun({_, ChildPid}) -> ChildPid ! {added_new_child, Pid, Name} end, State#state.children),
          io:format("ChildList: ~p~n", [State#state.children]),
          {noreply, State#state{children = NewChildren}};
```

# Задание 3
Обновите spec для keylist.erl и keylist_mgr.erl

spec для создания нового дочернего процесса 
```
-spec start_child(Params :: #{name => atom(), restart => permanent | temporary}) -> ok.
```

# Задание 4
Тестирование реализованных модулей
```
1> keylist_mgr:start(). % запускаем главный процесс
{ok,<0.87.0>}
2> keylist_mgr:start_child(#{name => keylist1, restart => permanent}).
ok
ChildList: []
3> keylist_mgr:start_child(#{name => keylist2, restart => permanent}).
ChildList: [{keylist1,<0.90.0>}]
ok
4> keylist_mgr:start_child(#{name => keylist3, restart => temporary}).
ok
5> whereis(keylist1).
<0.90.0>
6> whereis(keylist2).
<0.91.0>
7> whereis(keylist3). #Запустив процесс с restart => temporary мы его не запускаем
undefined
8> keylist:add(keylist1, key1, value1, "Comment1"). % Добавляем и проверяем функционал keylist
[{key1,value1,"Comment1"}]
9> keylist:is_member(keylist1, key1).
true
10> keylist:find(keylist1, key1).
{key1,value1,"Comment1"}
11> keylist:take(keylist1, key1).
{key1,value1,"Comment1"}
12> keylist:delete(keylist1, key1).
ok
13> keylist_mgr:stop_child(keylist1). # Останавливаем дочерний процесс
ok
14> whereis(keylist1).
undefined
15> whereis(keylist2). % keylist1 завершился, а keylist2 продолжает свою работу.
<0.91.0> 
16> keylist_mgr:stop(). % Останавливаем главный процесс
ok
17> whereis(keylist2). % Останавливается и дочерний 
undefined
18>
```