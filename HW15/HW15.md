# HW15

# Код door.erl
```
%%%-------------------------------------------------------------------
%%% @author kolpa
%%% @copyright (C) 2023, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 07. дек. 2023 12:45
%%%-------------------------------------------------------------------
-module(door).
-author("kolpa").

-behaviour(gen_statem).

%% API
-export([start_link/1, enter/2, print_entered_nums/1, change_code/2]).

% Callbacks
-export([init/1, callback_mode/0, locked/3, open/3, suspended/3, terminate/3]).

-record(door_data, {code, entered = [], attempts = 0}).

-define(SERVER, ?MODULE).

%% API
% Создание процесса
-spec start_link(InitCode :: tuple()) -> {ok, Pid :: pid()}.
start_link(InitCode) ->
  gen_statem:start_link(?MODULE, [InitCode], []).

% Ввод чисел
-spec enter(Pid :: pid(), Num :: integer()) -> ok.
enter(Pid, Num) ->
  gen_statem:call(Pid, {enter, Num}).

% Вывод ранее введённых чисел до достижения open
-spec print_entered_nums(pid()) -> ok.
print_entered_nums(Pid) ->
  gen_statem:cast(Pid, print_entered_nums).

% Изменение кода
-spec change_code(Pid :: pid(), NewCode :: tuple()) -> ok.
change_code(Pid, NewCode) ->
  gen_statem:call(Pid, {change_code, NewCode}).

% Callbacks
init([InitCode]) ->
  io:format("Init callback was called ~n"),
  process_flag(trap_exit, true),
  {ok, locked, #door_data{code = InitCode, attempts = 0}}.

callback_mode() ->
  state_functions.

% Locked Handler
locked({call, From}, {enter, Num}, #door_data{code = Code, entered = Entered, attempts = Attempts} = DoorData) ->
  io:format("Entered code ~p, current data ~p~n", [Num, DoorData]),
  case length([Num | Entered]) == length(Code) of
    true ->
      EnteredCode = lists:reverse([Num | Entered]),
      case Code == EnteredCode of
        % Код верный, открываем дверь
        true ->
          {next_state, open, DoorData#door_data{entered = []}, [{reply, From, {ok, open}}, {state_timeout, 10000, open_door_timeout}]};
        % Попытка неверная прибавляем попытку
        false ->
          NewAttempts = Attempts + 1,
          % 3 Попытки
          case NewAttempts >= 3 of
            true ->
              {next_state, suspended, DoorData#door_data{entered = [], attempts = 0}, [{reply, From,{error, timeout}}, {state_timeout, 10000, door_timeout}]};
            false ->
              {keep_state, DoorData#door_data{entered = [], attempts = NewAttempts}, [{reply, From, {error, wrong_code}}]}
          end
      end;
    false ->
      {keep_state, DoorData#door_data{entered = [Num | Entered]}, [{reply, From, {ok, next}}]}
  end;

locked(cast, print_entered_nums, #door_data{entered = Entered} = _DoorData) ->
  io:format("Entered nums ~p~n", [lists:reverse(Entered)]),
  keep_state_and_data;
locked(info, {link, Pid}, _Doordata) ->
  link(Pid),
  io:format("Received link, created link with ~p", [Pid]),
  keep_state_and_data;
locked(info, Msg, DoorData) ->
  io:format("Received unhandled msg ~p in State num ~p~n", [Msg, DoorData]),
  keep_state_and_data;
locked(info, {'EXIT', Pid, Reason}, DoorData) ->
  io:format("Received EXIT msg from ~p, reason ~p in State num ~p~n", [Pid, Reason, DoorData]),
  keep_state_and_data.

% Open Handler
open({call, From}, {enter, Num}, #door_data{code = _Code, entered = _Entered} = _DoorData) ->
  io:format("The door is open, handling Num ~p~n", [Num]),
  {keep_state_and_data, [{reply, From, {error, already_open}}]};
open(cast, print_entered_nums, #door_data{entered = Entered} = _DoorData) ->
  io:format("Entered nums while door is open: ~p~n", [lists:reverse(Entered)]),
  keep_state_and_data;
open({call, From}, {change_code, NewCode}, #door_data{code = _Code} = DoorData) ->
  io:format("Changing code to ~p~n", [NewCode]),
  {keep_state, DoorData#door_data{code = NewCode}, [{reply, From, locked}]};
open(info, {'EXIT', Pid, Reason}, _DoorData) ->
  io:format("Received EXIT msg from ~p, reason ~p", [Pid, Reason]),
  keep_state_and_data;
open(state_timeout, open_door_timeout, DoorData) ->
  {next_state, locked, DoorData#door_data{attempts = 0}}.

% Suspended Handler
suspended({call, From}, {enter, _Num}, _DoorData) ->
  io:format("The door is suspended, rejecting attempts to enter~n"),
  {keep_state_and_data, [{reply, From, {error, suspended}}]};
suspended(cast, _, _DoorData) ->
  io:format("Ignoring cast messages in the suspended state~n"),
  keep_state_and_data;
suspended(state_timeout, door_timeout, DoorData) ->
  {next_state, locked, DoorData#door_data{attempts = 0}}.

% Terminate Handler
terminate(Reason, State, DoorData) ->
  io:format("Terminating with reason ~p, in state ~p, with data ~p~n", [Reason, State, DoorData]),
  ok.
```

# Result

```
% Тестирую запуск процесса, ввод кода, смену кода, вывод уже введённых значений
46> {ok, Pid} = door:start_link([1,2,3,4]).
Init callback was called
{ok,<0.133.0>}
47> door:enter(Pid, 1).
Entered code 1, current data {door_data,[1,2,3,4],[],0}
{ok,next}
48> door:enter(Pid, 2).
Entered code 2, current data {door_data,[1,2,3,4],[1],0}
{ok,next}
49> door:enter(Pid, 3).
Entered code 3, current data {door_data,[1,2,3,4],[2,1],0}
{ok,next}
50> door:enter(Pid, 4).
Entered code 4, current data {door_data,[1,2,3,4],[3,2,1],0}
{ok,open}
51> door:change_code(Pid, [5,6,7,8]).
Changing code to [5,6,7,8]
locked
52> door:enter(Pid, 1).
Entered code 1, current data {door_data,[5,6,7,8],[],0}
{ok,next}
53> door:enter(Pid, 2).
Entered code 2, current data {door_data,[5,6,7,8],[1],0}
{ok,next}
54> door:enter(Pid, 3).
Entered code 3, current data {door_data,[5,6,7,8],[2,1],0}
{ok,next}
55> door:print_entered_nums(Pid).
Entered nums [1,2,3]
ok
% Тестирую блокировку при 3-ёх ошибочных вводах.
29> door:enter(Pid, 1).
Entered code 1, current data {door_data,[5,6,7,8],[],0}
{ok,next}
30> door:enter(Pid, 2).
Entered code 2, current data {door_data,[5,6,7,8],[1],0}
{ok,next}
31> door:enter(Pid, 3).
Entered code 3, current data {door_data,[5,6,7,8],[2,1],0}
{ok,next}
32> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[3,2,1],0}
{error,wrong_code}
33> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[],1}
{ok,next}
34> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4],1}
{ok,next}
35> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4,4],1}
{ok,next}
36> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4,4,4],1}
{error,wrong_code}
37> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[],2}
{ok,next}
38> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4],2}
{ok,next}
39> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4,4],2}
{ok,next}
40> door:enter(Pid, 4).
Entered code 4, current data {door_data,[5,6,7,8],[4,4,4],2}
{error,timeout}
41> door:enter(Pid, 4).
The door is suspended, rejecting attempts to enter
{error,suspended}
42> door:enter(Pid, 4).
The door is suspended, rejecting attempts to enter
{error,suspended}
43> door:enter(Pid, 4).
The door is suspended, rejecting attempts to enter
{error,suspended}
44> door:enter(Pid, 4).
The door is suspended, rejecting attempts to enter
{error,suspended}
```