# HW12

Из представленной статьи были полученны понятия о представлении строк в Erlang.
Описанные функциии в задании предназначены для работы с строкивыми и байтами значениями.

# Result

```
1> string:tokens("apple,orange,banana", ",").
["apple","orange","banana"] % Разбивает строку на подстроки на основе разделителя.
2> string:join(["apple", "orange", "banana"], ", ").
"apple, orange, banana" % Объединяет список строк в одну строку, используя указанный разделитель.
3> string:strip(" hello  !").
"hello  !" % Удаляет начальные и конечные пробелы из строки.
4> string:strip("...Hello.....", both, $.). % 1- строка, 2- откуда начинать поиск указанного символа, 3- что искать
"Hello" 
5> string:uppercase("hello").
"HELLO" % Преобразует символы в верхний регистр
6> string:lowercase("WORLD").
"world" % В нижний
7> string:to_integer("123"). % Функция преобразует строку в целое число. Он возвращает кортеж с преобразованным целым числом и всеми оставшимися символами в строке.
{123,[]}
8> string:to_integer("123abc").
{123,"abc"}
9> erlang:list_to_integer("123"). % Функция также преобразует строку в целое число. Однако она не возвращает оставшиеся символы в строке.
123
10> erlang:list_to_integer("123abc"). % Из-за этого при указания в качестве аргумента строку содержащую буквенные символы или спец. символы возникает exception
** exception error: bad argument
     in function  list_to_integer/1
        called as list_to_integer("123abc")
        *** argument 1: not a textual representation of an integer
11> erlang:list_to_integer("abc").
** exception error: bad argument
     in function  list_to_integer/1
        called as list_to_integer("abc")
        *** argument 1: not a textual representation of an integer
12> erlang:byte_size(<<1,2,3,4,5>>). % Функция определяет размер дваичниго файла в байтах
5
13>Binary = <<"some long string">>,
    {Part1, Part2} = erlang:split_binary(Binary, 4),
    io:format("Part 1: ~p~nPart 2: ~p~n", [Part1, Part2]).
Part 1: <<"some">>
Part 2: <<" long string">>
ok % Используется для разделения двоичного файла на две части на основе указанной позиции индекса.
14> erlang:binary_part(<<"some long string">>, 5, 4).
<<"long">> % Используется для извлечения части двоичного файла на основе указанной начальной позиции и длины.
15> Str = <<"Hello World!"/utf8>>.
<<"Hello World!">>
16> binary:split(Str, [<<" ">>]).
[<<"Hello">>,<<"World!">>]
17> binary:split(Str, [<<" ">>, <<"l"/utf8>>]).
[<<"He">>,<<"lo World!">>] % Используется для разделения двоичного файла на несколько частей на основе заданного шаблона.
18> Binary = <<"abcde">>,
   Pattern = <<"bcd">>,
   {Pos, Length} = binary:match(Binary, Pattern),
   io:format("Match found at position ~p with length ~p~n", [Pos, Length]).
Match found at position 1 with length 3
ok % Используется для поиска первого вхождения шаблона в двоичном файле и возврата позиции и длины совпадения.
19> Binary = <<"abc abc abc">>,
   Pattern = <<"ab">>,
   Matches = binary:matches(Binary, Pattern),
   io:format("Matches: ~p~n", [Matches]).
Matches: [{0,2},{4,2},{8,2}]
ok % Возвращает список кортежей, где каждый кортеж представляет совпадение с позицией и длиной совпадения.
20> Subject = <<"abcde">>,
   Pattern = <<"b">>,
   Replacement = <<"[]">>,
   Result = binary:replace(Subject, Pattern, Replacement),
   io:format("Result: ~p~n", [Result]).
Result: <<"a[]cde">>
ok % Используется для создания нового двоичного файла путем замены частей предметного двоичного файла, соответствующих заданному шаблону, содержимым заменяющего двоичного файла.
21> f().
ok
22> Subject = <<"abcde">>,
    Pattern = <<"b">>,
    Replacement = <<"[]">>,
    Options = [{insert_replaced, 1}],
    Result = binary:replace(Subject, Pattern, Replacement, Options),
    io:format("Result: ~p~n", [Result]).
Result: <<"a[b]cde">>
ok %  Возвращает новый двоичный файл, в котором все вхождения шаблона в объектном двоичном файле заменяются содержимым замещающего двоичного файла.
23> Binary = <<97, 98, 99>>,
    List = binary_to_list(Binary),
    io:format("List: ~p~n", [List]).
List: "abc"
ok % Используется для преобразования двоичного файла в список целых чисел, соответствующих байтам двоичного файла.
24> f().
26> list_to_binary(List). % Из списка в двоичный файл
<<"abc">>
27> NestedList = [[1, 2, 3], [4, [5, 6]], [7, 8]],
    FlattenedList = lists:flatten(NestedList),
    io:format("Flattened List: ~p~n", [FlattenedList]).
Flattened List: [1,2,3,4,5,6,7,8]
ok %  Используется для объединения списка вложенных списков в один список.
```