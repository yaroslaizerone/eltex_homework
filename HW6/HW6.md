# HW6

## Задание 1
В Eshell выполните List comprehensions (Задания из книги Чезарини Erlang Programming)
●	Используя генераторы списков, создайте набор целых чисел от 1 до 10, которые делятся на три (например, [3,6,9]).
●	Используя генераторы списков, удалите все нецелые числа из списка. Возвращаться список целых чисел в квадрате: [1, “hello”, 100, boo, "boo", 9] должен возвращать [1, 10000, 81].

## Result
Числа делятся на 2 без остатка: 
```
DivisibleByThree = [X || X <- lists:seq(1, 10), X rem 2 =:= 0].
[2,4,6,8,10]
```
9> SquareIntegers = [X * X || X <- [1, "hello", 100, boo, "boo", 9, 1.3, 11, 10101], is_integer(X)].       
[1,10000,81,121,102030201]

## Задание 2
Прокомментируйте код и возникшие ошибки:
<<X:4,Y:2>> = <<42:6>>.
<<C:4,D:4>> = << 1998:6 >>. 
<<C:4,D:2>> = << 1998:8 >>.

## Result 

```
11> <<X:4,Y:2>> = <<42:6>>.  %% Шаблон левой стороны и значение правой стороны имеют размер 6 бит. При pattern matching значение присвается без каких либо проблем.
<<42:6>>



12> <<C:4,D:4>> = << 1998:6 >>. %% Шаблон левой стороны имеет размер 8 бит, а значение правой стороны имеют размер 6 бит. При pattern matching значение и шаблон не совместимы.
** exception error: no match of right hand side value <<14:6>>



13> <<C:4,D:2>> = << 1998:8 >>. %% Аналогичная ситуация с шаблоном и значением, где значение превышает принимаемое значение шаблона.
** exception error: no match of right hand side value <<"Î">>

%% Для решения данных проблем необходимо предусматреть, что шаблон может принять заданное значение, а значение подходит к шаблону. Как в строке Eshell 12.
```

## Задание 3 

3.	Создайте модуль protocol.erl и объявите рекорд 
#ipv4{
	version,
	Ihl,
	tos,
	total_length,
	…,
	data
} все поля из IPv4 Headers (рассмотрели на лекции).

Исключение `throw` Позволяет генерировать уникальную ситуацию и передавать информацию о ней для дальнейшей обработки.
## Result 

```
5> c("protocol.erl").
{ok,protocol}
6> DataWrongFormat = <<4:4, 6:4, 0:8, 0:3>>.
<<70,0,0:3>>
7> DataWrongVer = <<6:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello" >>.  
<<102,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
  101,108,108,111>>
8> Data1 = <<4:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello" >>.
<<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
  101,108,108,111>>
9> Data2 = <<4:4, 8:4, 2:8, 232:16, 0:8, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hi" >>.
<<72,2,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,105>>
10> spawn(fun() -> protocol:ipv4(Data1) end).
Received data <<"hello">>
<0.114.0>
```
Запуск с изменёнными параметрами в новом вызове Eshell

```
1> c("protocol.erl").
{ok,protocol}
2>  Data2 = <<4:4, 8:4, 2:8, 220:16, 0:8, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hi" >>.
<<72,2,0,220,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,105>>
3> spawn(fun() -> protocol:ipv4(Data2) end).
<0.93.0>
=ERROR REPORT==== 5-Nov-2023::23:15:10.472000 ===
Error in process <0.93.0> with exit value:
{{nocatch,invalid_data},[{protocol,ipv4,1,[{file,"protocol.erl"},{line,56}]}]}
```

```
6> self().
<0.85.0>
7> DataWrongFormat = <<4:4, 6:4, 0:8, 0:3>>.
<<70,0,0:3>>
8> spawn(fun() -> protocol:ipv4(DataWrongFormat) end).
<0.99.0>
=ERROR REPORT==== 5-Nov-2023::23:24:10.617000 ===
Error in process <0.99.0> with exit value:
{{nocatch,invalid_data},[{protocol,ipv4,1,[{file,"protocol.erl"},{line,56}]}]}

9> self().
<0.85.0>
```
pid не изменился. Потому что pid остается неизменным, так как управление возвращается к исходному процессу.

# Задание 4 
В модуле protocol реализуйте функцию protocol:ipv4_listener/0, которая ожидает получения сообщения {ipv4, From, BinData} и если получает, то вызывает функцию protocol:ipv4(BinData) и отправляет результат From. 
Добавьте охранное выражение в receive, что BinData это binary.
Обработайте случай, что функция получила сообщение другого формата и выведите ошибку или вызовите exception.

Пример:
ipv4_listener() 
receive 
{ipv4, From, BinData} ->
	From ! ipv4(Data); %% Возвращаем результат
…
end. 
	
Eshell:
Запустите функцию protocol:ipv4_listener/0 в новом процессе с помощью spawn/3 или spawn/1. Сохраните pid нового процесса в переменную ListenerPid.

Отправьте из Eshell сообщение ListenerPid с валидными данными Data1 или Data2. 
ListenerPid ! {ipv4, self(), Data}


## Result
```
10> c("protocol.erl").
{ok,protocol}
11> ListenerPid = spawn(fun() -> protocol:ipv4_listener() end).
<0.107.0>
12> ListenerPid ! {ipv4, self(), Data1}.
* 1:30: variable 'Data1' is unbound
13>  Data1 = <<4:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello" >>.       
<<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
  101,108,108,111>>
14> ListenerPid ! {ipv4, self(), Data1}.
Received data <<"hello">>
{ipv4,<0.85.0>,
      <<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
        101,...>>}
15> Data2 = <<4:4, 8:4, 2:8, 220:16, 0:8, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hi" >>.
<<72,2,0,220,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,105>>
16> ListenerPid ! {ipv4, self(), Data2}.
{ipv4,<0.85.0>,
      <<72,2,0,220,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
        105>>}
```